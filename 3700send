#!/usr/bin/env python3

import sys
import socket
import select
import datetime
import json
import time

MSG_SIZE = 1500
DATA_SIZE = 1472
TIMEOUT = 30
WINDOW_SIZE = 10
lastMsg = None
sentMessages = []
messageQueue = []


# Done, don't touch!
def log(string):
    sys.stderr.write(datetime.datetime.now().strftime(
        "%H:%M:%S.%f") + " " + string + "\n")
    sys.stderr.flush()


def enqueue_packet(seqn):
    msg = {"sequence": seqn, "data": "", "ack": False, "eof": False}
    log("seq number is: " + str(seqn))
    overhead = len(json.dumps(msg))
    msg["data"] = sys.stdin.read(DATA_SIZE - overhead)
    messageQueue.append(msg)
    return seqn + len(msg['data'])

def send_next_packet(seqn, sock, dest):
    global lastMsg
    assert(len(messageQueue) > 0)
    msg = messageQueue[0]
    if len(msg["data"]) > 0:
        assert (len(
            msg) <= DATA_SIZE), f"ERROR: Datagram is longer ({len(msg)}) than {DATA_SIZE} bytes!!!"
        if sock.sendto(json.dumps(msg).encode('ascii'), dest) < len(msg):
            log("[error] unable to fully send packet")
        else:
            log("[send data] " + str(seqn) +
                " (" + str(len(msg["data"])) + ")")
            lastMsg = msg
        return seqn + len(msg["data"])
    return seqn


# Done, don't touch!
def teardown(seqn, sock, dest):
    log("tearing down!!!")
    msg = json.dumps(
        {"eof": True, "data": "", "sequence": seqn, "ack": False}).encode('ascii')
    tries = 0
    while (tries < 10):
        tries += 1
        sock.sendto(msg, dest)
        time.sleep(0.05)

# Done, don't touch!
def setup():
    # Bind to localhost and an ephemeral port
    ip_port = sys.argv[1]
    udp_ip = ip_port[0:ip_port.find(":")]
    udp_port = int(ip_port[ip_port.find(":")+1:])
    dest = (udp_ip, udp_port)
    seqn = 0

    # Set up the socket
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.settimeout(TIMEOUT)

    # Send first packet
    enqueue_packet(seqn)
    new_seqn = send_next_packet(seqn, sock, dest)
    if new_seqn == seqn:
        teardown(seqn, sock, dest)
    seqn = new_seqn
    return (seqn, sock, dest)

# Done, don't touch!
def get_ack(seqn, sock, dest):
    while True:
        log("ABOUT TO SLEEP")
        result = None
        ready = select.select([sock], [], [], 0.5)
        if ready[0]:
            result = sock.recvfrom(MSG_SIZE)
        else:
            log("didn't receive an ack")
            send_next_packet(seqn, sock, dest)
            continue
        (data, _addr) = result
        return json.loads(data.decode('ascii'))


def main():
    info = setup()
    seqn = info[0]
    sock = info[1]
    dest = info[2]

    # Now read in data, send packets
    while True:
        # enqueue WINDOW_SIZE messages, send them all
        # Increment IN_TRANSIT per message sent
        # Wait for 2 seconds for acks - for each ack, decrement IN_TRANSIT
        # enqueue WINDOW_SIZE - IN_TRANSIT messages, send them all
        # Increment IN_TRANSIT per message sent
        decoded = get_ack(seqn, sock, dest)
        # If there is an ack, send next packet
        if decoded['ack'] == seqn:
            log(f"[recv ack] {seqn}")
            messageQueue.remove(lastMsg)
            # Try to send next packet; break if no more data
            enqueue_packet(seqn)
            new_seq = send_next_packet(seqn, sock, dest)
            if new_seq == seqn:
                break
            seqn = new_seq
        log(f"(seqn {seqn})")
    teardown(seqn, sock, dest)


if __name__ == '__main__':
    main()
